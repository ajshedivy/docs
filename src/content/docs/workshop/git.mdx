---
title: Git and IBM i workshop
template: splash
---

import { Aside, CardGrid, Card } from '@astrojs/starlight/components';

## Outline

1. Requirements - vscode, extensions, github account, github desktop
2. Goals
3. Understanding local development - creating local folder, open in VS Code
4. Compiling your first program - folder structure, creating hello world, creating actions, conmpiling
5. Initialising your git repository - initialise git repo button in VS Code
6. Making additional changes - making commits into your repo
7. Making a public repository - making a public repository on GitHub from your repo
8. Cloning repositories - clone from github using GHD, open in VS Code
9. Making branches - make the branch, make and push your commits
10. Making a pull request - make a PR on GitHub

---

## Requirements

This is a BYOD (bring your own device) workshop and some software and accounts are required.

### Tasks

#### Install git

If you're on Mac or Linux, git is usually shipped with the OS. If you are on Windows, you may need to install git if you do not have it.

[Check out the git website for installing git](https://git-scm.com/download/win).

#### Signup to GitHub

If you don't have a GitHub account, you are going to need one for this workshop. We will be creating new repositories and working with others.

[Sign up here](http://github.com/signup).

#### Install GitHub Desktop

We will use GitHub Desktop to make cloning and working with git repositories easier. It is a great tool for beginners.

[Download it here for free](https://desktop.github.com).

**After you have installed GitHub Desktop**, launch GitHub Desktop and sign into your GitHub account. This will make working with GitHub repositories easier.

#### Install Visual Studio Code

We are using VS Code to write our code. It is a free, open-source editor with great extensibility.

[Download it here for free](https://code.visualstudio.com/download).

#### Install Code for IBM i

We are using the Code for IBM i extension to write, deploy and compile our RPGLE code. It is an extension that can be used for IBM i development in many ways.

**After you have installed Visual Studio Code**, then go ahead and install the [Code for IBM i extension](https://marketplace.visualstudio.com/items?itemName=HalcyonTechLtd.code-for-ibmi), or, to make life easier in the future, install the [IBM i Development pack](https://marketplace.visualstudio.com/items?itemName=HalcyonTechLtd.ibm-i-development-pack).

#### Access to an IBM i

If you are doing this workshop as part of a hosted lab, then a user profile and system will be provided to you. If you're using your own system, then ensure SSH is running on your system. [Check out the requirements](../../).

---

## Goals

The main goal of this workshop is to understand how you can write IBM i code (be it RPGLE, COBOL, CL, etc) when storing source code inside of a git repository. This is made easy through some of the functionality provided in Code for IBM i (the extension) as part of Visual Studio Code. GitHub Desktop is just a git client, which makes it easy for beginners to work with GitHub repositories.

### Terminology

Here are some common terms that you will read throughout this workshop.

| Term | Meaning |
| - | - |
| Repository | The place, usually a directory, where files and history of those files are stored. |
| Clone | The act of 'copying' (literally cloning) the repository from another location. |
| Push | Pushing commits from one repository to another |
| Deploy | Moving files/sources from your local workspace to an IBM i server |
| Workspace | Visual Studio Code with one or more folders opened |

---

## Understanding Local Development

Unlike developing in source members, or developing in the IFS, IBM i code will actually be written on a local device - like a laptop or desktop system. This is actually new to the ecosystem, since it is not typically done for IBM i development.

This is done because all of the best git tools are developed to run on systems other than IBM i (GitHub Desktop being one of them!) and using git without great tools can be painful for beginners.

This sometimes leads to the question of 'well how do we compile if not developing on IBM i'; this is where the 'Deploy' process comes in. More on that later.

### Tasks

#### 1. Create a new folder on your local device

Simply create a new directory somewhere on your device. This directory will become a git repository.

```sh
mkdir myrepo
```

#### 2. Opening a Workspace Folder

Opening a folder in Visual Studio Code adds that folder to that Workspace. You need at least one folder open in the Visual Studio Code workspace for local development.

To open a directory in Visual Studio Code, you can go to Fileâ†’Open and select the folder you created in step 1.

#### 3. Connect to an IBM i system

Using the Code for IBM i extension, you can create a new connection to an IBM i system.

![](./assets/connect_1.png)

<Aside type="note">
Ensure the folder is opened before connecting to a system.
</Aside>

#### 3. Setting the deploy location

If it is the first time connecting with the workspace it will prompt the user to set a default Deploy directory.

![](./assets/deploy_1.png)

If you would prefer to change the default location, the user can right-click on any directory in the IFS Browser and select the 'Deploy Workspace to location' option.

The user can change the deploy directory at any by using the same right-click option on another directory.

---

## Compiling your first program

Now that you have a directory to write some code and a connection made in Visual Studio Code, it's almost time to write code. Before that, there are some concepts we must understand.

#### Folder structure

Since we are not developing in source members, there are not as many rules as the QSYS file system.

* Files can be any case
* Can use any extension with any length
* Unlike QSYS, we can have folders within folders

It is not an issue to continue using folder names like `QRPGLESRC`, or `qddssrc`, but it is always recommended to use lowercase naming.

You can read more on [folder structure for git projects](../../developing/local/structure/) in the Code for IBM i documentation.

#### How Actions are stored

Actions are synonymous for compile commands. An Action defines how the compile command should be run. When doing local development, Actions are stored in the folder `.vscode`, and inside that `actions.json` (`.vscode/actions.json`).

Here is an example Action that would be found in the `actions.json` file:

```json
[
  {
    "name": "Compile with CRTBNDRPG ðŸ”¨",
    "command": "CRTBNDRPG PGM(&CURLIB/&NAME) SRCSTMF('&RELATIVEPATH') OPTION(*EVENTF) DBGVIEW(*SOURCE) TGTRLS(*CURRENT) TGTCCSID(*JOB)",
    "environment": "ile",
    "deployFirst": true,
    "extensions": [
      "RPGLE"
    ]
  }
]
```

Actions are stored as part of the repository so they can be shared between developers. Generally, we want developers to use the same compile commands. Therefore, it is convenient to store them as part of the repository.

### Tasks

#### 1. Creating `actions.json`

<CardGrid>
<Card>
There is a tool that can generate an initial `actions.json` file for you. After connecting to a system, open the command palette (**F1**) and search for 'Launch Actions Setup'. This shows a multi-select window where the user can pick which technologies they're using. Based on the selection, an `actions.json` will be created. 

**For the next step, ensure RPGLE is selected.**

</Card><Card>
![](./assets/actions_tool.png)

</Card></CardGrid>

#### 2. Set your current library

Notice in your `action.json` file, where each command is defined, the `&CURLIB` variable is used in place of the target library. This variable is set based on the User Library List view in Visual Studio Code.

<CardGrid>
<Card>

The current library should be unique to your user and not shared by multiple users. You are able to right click on the current library and select 'Change current library' and enter the unique library.

</Card><Card>

TODO: screenshot of current library

</Card></CardGrid>

<Aside type="note">
If you are following this workshop as part of a hosted lab, a library will be provided to you.
</Aside>

#### 3. Writing the first program

Next, you can create your first program.

<CardGrid>
<Card>

1. Create a directory and give it a name like `src`, or `qrpglesrc`, or whatever name you would like.
2. Create a new file inside of that directory named `mypgm.pgm.rpgle`. We use `.pgm.` for later, as it is an indicator that it is a program.
3. Fill the new file with the source code shown here.

</Card><Card>

```rpgle
**free

dcl-s mytext char(20);

mytext = 'Hello from the world';

dsply mytext;

return;
```

</Card></CardGrid>

#### 4. Deploy and build

Once you have connecting to a system, setup the repo Actions and created your first piece of source code, then it is time to build that source code. From here on out, the dev-test loop is simple: make changes and then build.

To build, from your source code you can either:

1. Use the shortcut: Control + E (Windows/Linux), Command + E (Mac)
2. Find the 'Run Action' button in the editor UI.

<CardGrid>
<Card>

This will show a quickpick so the user can select which deployment method they want to use. **To keep things simple, use Compare if it shown**.

</Card><Card>

![](./assets/deploy_2.png)

</Card></CardGrid>

Following that, another quickpick is going to show with a list of the Actions as defined in the `actions.json` file. If you correctly selected *RPGLE* when creating the Actions, then **you should see an option for 'Create Bound RPG Program'**. Select that, and the deploy and build will commence. Following the build, you can navigate to the Terminal tab to see the command that was submitted, as well as the spool file from the compiler.

TODO: screenshot showing compiled code with spool open

#### 5. Using copybooks / includes

When developing locally, 'member style' includes are no longer used for `/COPY` or `/INCLUDE` statements. Instead, we can use 'posix style' includes, which means using a path relative to the root of the directory.

<CardGrid>
<Card>

1. Create a new directory for copybooks/header files. Usually a name like `qrpgleref`, or `headers`, works.
2. Create a brand new source file in that new directory, named `constants.rpgleinc`, with the content shown here:

</Card><Card>

```rpgle
**free

dcl-c MYLABEL 'Hello from the world';
```

</Card></CardGrid>

<CardGrid>
<Card>

3. Go back to the original source that was created and add a `/copy` or `/include` statement to bring in the new file that was created.
4. Add a reference to the constant that was defined in the included file.

</Card><Card>

```rpgle
**free

/copy 'qrpgleref/constants.rpgleinc'

dcl-s mytext char(20);

mytext = MYLABEL;

dsply mytext;

return;
```

</Card></CardGrid>

5. Recompile your source using the shortcut (Command/Control+E) or the UI.

## Initialising your git repository

<Aside type="note">
Going forward, git is required on your system. See the requirements at the start of this workshop for a list.
</Aside>

Your repositories should have three files at this point:

1. `mypgm.pgm.rpgle`
2. `constants.rpgleinc`
3. `actions.json`

To track this files in git, we need to turn the root directory with these files into a git repository. This can be done in two ways:

1. from the command line: `git init`, or
2. through Visual Studio Code's Source Control view. Switch to that view and select the 'Initialise git repository' and then the view will show the files to be tracked.

<CardGrid>
<Card>

TODO: screenshot showing 'initialise git repository'

</Card><Card>

TODO: screenshot showing untracked files in source control view

</Card></CardGrid>


<CardGrid>
<Card>

All new files in the Source Control view have the letter 'A' next to this, which stands for 'Added'. It is 'added' because it is a new file to the git repository. When you hover over the files in the view, you will see a plus (+) icon appear on it (as well as the parent note). **Select the plus (+) on each file to stage the file**.

</Card><Card>

TODO: screenshot of the staged files with a commit message ready

</Card></CardGrid>

When the files are staged, enter a commit message above and then select 'Commit'. This will take the staged files, create a commit with the changes and store them into the history of the repository. The list of files will then be empty, since it will show only changes sources in the 'working tree' (e.g. the directory).